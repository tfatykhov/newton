# 007.3 â€” Improve `_is_informational()` Detection

> **Status:** Implemented (Phase 1)
> **Priority:** P0
> **Issue:** #38
> **Estimated effort:** ~1-2 hours

## Problem

`_is_informational()` in `layer.py` only matches 5 keyword patterns:
```python
info_patterns = [
    "current status", "available tools",
    "i remember", "my memory", "what i know",
]
```

This misses most informational responses â€” git pull status dumps, project summaries, acknowledgments, confirmations, and simple Q&A answers all slip through and become "decisions" in the DB.

## Root Cause

The filter was deliberately conservative (006.2 design) to avoid false positives. But it's too conservative â€” the DB has 8+ junk decisions that are clearly informational.

## Solution

### 1. Expand Keyword Patterns

Add patterns observed in actual junk decisions:

```python
info_patterns = [
    # Status & inventory
    "current status", "available tools", "here's what",
    "here is what", "here are the", "summary of",
    
    # Memory recall
    "i remember", "my memory", "what i know",
    "i recall", "from memory", "i found",
    
    # Git / repo status
    "repo pulled", "repo is at", "git pull",
    "latest commit", "new branch", "new pr",
    "commits since", "merged to main",
    
    # Acknowledgment / confirmation
    "got it", "understood", "noted", "will do",
    "sure thing", "okay,", "alright,",
    
    # Simple answers
    "the answer is", "it means", "this is because",
    "that's correct", "you're right",
    
    # Lists / enumerations
    "here's a list", "the following",
]
```

### 2. Structural Signals

Beyond keywords, check structural indicators:

```python
def _is_informational(self, turn_result: TurnResult) -> bool:
    # If agent explicitly recorded a decision, it's real
    tools_used = {r.tool_name for r in turn_result.tool_results}
    if "record_decision" in tools_used:
        return False

    response = turn_result.response_text
    response_lower = response[:500].lower()

    # 1. Keyword patterns (expanded)
    if any(p in response_lower for p in self._INFO_PATTERNS):
        return True

    # 2. Structural: starts with emoji + header (status dump pattern)
    import re
    if re.match(r'^[ðŸ”§ðŸ¤–ðŸ“ŠðŸ§ ðŸ“Œâš¡ðŸŸ¢]\s', response[:10]):
        return True

    # 3. Structural: very short response (< 50 chars) = likely acknowledgment
    if len(response.strip()) < 50 and not tools_used:
        return True

    # 4. Structural: response is mostly a list (> 60% lines start with - or â€¢)
    lines = [l.strip() for l in response.split('\n') if l.strip()]
    if lines:
        list_lines = sum(1 for l in lines if l.startswith(('-', 'â€¢', '*', 'ðŸ“Œ', 'ðŸ”§')))
        if list_lines / len(lines) > 0.6 and len(lines) > 3:
            return True

    # 5. No decision language: lacks words suggesting a choice was made
    decision_signals = [
        "decided", "chose", "will use", "going with",
        "switching to", "plan:", "approach:",
        "trade-off", "instead of", "rather than",
    ]
    if not any(s in response_lower for s in decision_signals):
        # If no decision language AND matches a question frame, it's informational
        # (answering questions != making decisions)
        return True  # TODO: this may be too aggressive, consider frame check

    return False
```

### 3. Frame-Based Heuristic

Conversation frame responses are almost never decisions:

```python
# If frame is conversation AND no record_decision tool used, it's informational
if turn_context.frame.frame_id == "conversation" and "record_decision" not in tools_used:
    return True
```

## Phased Approach

**Phase 1 (this PR):** Expand keyword patterns + add emoji/short-response structural checks. Low risk.

**Phase 2 (future):** Add decision-language detection + frame heuristic. Higher risk of false positives â€” needs tuning.

## Files Changed

| File | Change |
|------|--------|
| `nous/cognitive/layer.py` | Expand `_is_informational()` (~30 lines) |
| `tests/test_cognitive_layer.py` | Tests for new patterns (~60 lines) |

## Test Cases

```python
# Should be informational (True)
assert _is_informational("ðŸ¤– Nous â€” Current Status\nðŸŸ¢ Agent...")  # emoji header
assert _is_informational("Got it, will do.")  # acknowledgment  
assert _is_informational("âœ… Repo pulled â€” now at efedacd")  # git status
assert _is_informational("Here's what I found in memory...")  # recall

# Should NOT be informational (False) 
assert not _is_informational("Decided to use Option B because...")  # real decision
assert not _is_informational("[record_decision called]")  # explicit tool
```
