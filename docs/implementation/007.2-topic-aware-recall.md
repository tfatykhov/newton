# 007.2 — Topic-Aware Context Recall

> **Status:** Planned
> **Priority:** P0
> **Issue:** #52
> **Estimated effort:** ~2-3 hours

## Problem

When the user switches topics (e.g. from Nous to cognition-engines), RECALL still returns decisions, facts, and episodes from the dominant topic. All 15 recalled items can be completely irrelevant because RECALL uses pure semantic similarity with no topic awareness.

Working memory correctly shows the new topic, but the context engine ignores it.

## Root Cause

`context.py` passes `input_text` (the raw user message) as the query to all memory searches:
```python
decisions = await self._brain.query(q_text, limit=limit, session=session)
facts = await self._heart.search_facts(q_text, limit=limit, session=session)
episodes = await self._heart.search_episodes(q_text, limit=limit, session=session)
```

When the user says "switch to cognition-engines, what do you know?" the query is generic — and the most similar items in the DB are from the dominant topic (Nous).

## Solution

### 1. Topic-Enhanced Query

Use working memory's current topic to enhance the recall query:

```python
# context.py — build()

# Get current topic from working memory
wm = await self._heart.get_working_memory(session_id, session=session)
current_topic = wm.current_task if wm else None

# Enhance query with topic context
if current_topic:
    q_text = f"{current_topic}: {input_text}"
```

This shifts the embedding toward topic-relevant results without requiring any schema changes.

### 2. Subject-Based Diversity Filter

After recall, enforce diversity — don't let one subject dominate:

```python
# context.py — after retrieving decisions

def _enforce_diversity(self, items: list, max_per_subject: int = 2) -> list:
    """Prevent one topic from dominating recall results."""
    seen_subjects: dict[str, int] = {}
    result = []
    for item in items:
        subject = getattr(item, 'subject', None) or 'unknown'
        # Normalize subject to first word (e.g. "nous spec 006.1" -> "nous")
        topic_key = subject.split()[0].lower() if subject else 'unknown'
        count = seen_subjects.get(topic_key, 0)
        if count < max_per_subject:
            result.append(item)
            seen_subjects[topic_key] = count + 1
    return result
```

Apply to each memory type after retrieval:
```python
decisions = self._enforce_diversity(decisions, max_per_subject=2)
facts = self._enforce_diversity(facts, max_per_subject=2)
episodes = self._enforce_diversity(episodes, max_per_subject=2)
```

### 3. Frame-Topic Alignment Check

If the frame and working memory topic are misaligned with the recalled content, log a warning and reduce confidence:

```python
# After recall, check alignment
topic_tokens = set(current_topic.lower().split()) if current_topic else set()
for decision in decisions:
    desc_tokens = set(decision.description[:100].lower().split())
    if topic_tokens and not topic_tokens & desc_tokens:
        # This decision has zero overlap with current topic
        decision._relevance_penalty = 0.3  # Applied during ranking
```

## Files Changed

| File | Change |
|------|--------|
| `nous/cognitive/context.py` | Topic-enhanced query, diversity filter (~40 lines) |
| `tests/test_context.py` | Tests for topic-aware recall (~80 lines) |

## Notes

- Topic enhancement is additive — if no working memory topic exists, behavior is unchanged
- Diversity filter is applied post-retrieval, before formatting — no DB changes needed
- The `max_per_subject=2` limit is conservative — allows some same-topic results while ensuring variety
- Works with existing `_format_*` methods unchanged
