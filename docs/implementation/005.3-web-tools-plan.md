# Implementation Plan: Spec 005.3 â€” Web Tools (Search & Fetch)

> Status: PLANNED  
> Estimated Effort: ~2.5 hours  
> Priority: P1  
> Prereq: 005.2 âœ…

---

## ğŸ” Current State Summary

| What | State |
|---|---|
| `httpx` | âœ… Already a core dep â€” no new packages needed for fetch |
| `ToolDispatcher` | âœ… Implemented in `tools.py` â€” plug-and-play |
| `register_builtin_tools()` pattern | âœ… Clean pattern in `builtin_tools.py` to follow exactly |
| `FRAME_TOOLS` in `runner.py` | âš ï¸ Has `"question": ["recall_deep"]` â€” needs `web_search`, `web_fetch` added |
| `config.py` | âš ï¸ No `web_search_enabled` or `search_api_key` settings yet |
| `.env.example` | âš ï¸ No web search env vars |
| `test_builtin_tools.py` | âœ… Perfect pattern for new `test_web_tools.py` to follow |
| A search API client | âŒ Not present â€” need to choose a provider |

---

## ğŸ”‘ Pre-Decision: Search API Provider

| Provider | Pros | Cons |
|---|---|---|
| **Brave Search** | Cheap (~$3/1k), clean API, no JS needed | Needs key |
| **Tavily** | AI-focused, returns clean summaries | Pricier |
| **SerpAPI** | Google results, very reliable | Most expensive |
| **DuckDuckGo (free)** | No key needed | Unofficial, fragile, rate-limited |

**Recommendation: Brave Search** â€” cheap, reliable REST API, excellent JSON response, aligns with Nous's privacy-first vibe. `httpx` is all you need to call it.

---

## ğŸ“¦ Phase Breakdown

### Phase A â€” Config & Settings (~15 min)

**File:** `nous/config.py`

Add 3 new settings:

```python
# Web tools (005.3)
web_search_enabled: bool = False
web_search_api_key: str = Field("", validation_alias="BRAVE_SEARCH_API_KEY")
web_search_max_results: int = 5
web_fetch_max_bytes: int = 500 * 1024  # 500KB
```

**File:** `.env.example`

```env
# Web Tools (005.3)
NOUS_WEB_SEARCH_ENABLED=false
BRAVE_SEARCH_API_KEY=your_brave_key_here
NOUS_WEB_SEARCH_MAX_RESULTS=5
```

---

### Phase B â€” Tool Handlers (~1h)

**New file:** `nous/api/web_tools.py`

Pattern mirrors `builtin_tools.py` exactly. Two handlers:

#### `web_search_tool(query, max_results)`
```
1. Validate web_search_enabled (return disabled message if not)
2. POST to https://api.search.brave.com/res/v1/web/search
   Headers: Accept: application/json, X-Subscription-Token: <key>
   Params: q=<query>, count=<max_results>
3. Parse JSON â†’ extract title, url, description for each result
4. Format as numbered list â†’ _mcp_response(text)
5. Handle: 401 (bad key), 429 (rate limit), timeout, no results
```

#### `web_fetch_tool(url)`
```
1. Validate URL scheme is http/https (block file://, etc.)
2. httpx.AsyncClient.get(url, follow_redirects=True, timeout=30)
   Custom User-Agent header (respectful bot identification)
3. Check Content-Type â€” only process text/html, text/plain
4. Truncate to web_fetch_max_bytes (default 500KB)
5. Strip HTML tags â†’ extract readable text (simple regex or html.parser)
6. Return clean text â†’ _mcp_response(text)
7. Handle: non-200, timeout, non-text content, SSL errors
```

**Key design notes:**
- No new deps â€” `html.parser` is stdlib, `httpx` already present
- Both return `_mcp_response(text)` for `ToolDispatcher` compatibility
- `_workspace_dir` pattern NOT needed (web tools don't touch filesystem)
- Closures inject `settings` at registration time (same as builtin pattern)

**Schemas:**

```python
_WEB_SEARCH_SCHEMA = {
    "type": "object",
    "description": "Search the web and return relevant results",
    "properties": {
        "query": {"type": "string", "description": "Search query"},
        "max_results": {"type": "integer", "default": 5, "minimum": 1, "maximum": 10},
    },
    "required": ["query"],
}

_WEB_FETCH_SCHEMA = {
    "type": "object",
    "description": "Fetch and read the text content of a URL",
    "properties": {
        "url": {"type": "string", "description": "URL to fetch (http/https only)"},
    },
    "required": ["url"],
}
```

**Registration function:**

```python
def register_web_tools(dispatcher: ToolDispatcher, settings: Settings) -> None:
    if not settings.web_search_enabled:
        return  # Don't register if disabled

    async def _web_search(query: str, max_results: int = 5):
        return await web_search_tool(query, max_results, _settings=settings)

    async def _web_fetch(url: str):
        return await web_fetch_tool(url, _settings=settings)

    dispatcher.register("web_search", _web_search, _WEB_SEARCH_SCHEMA)
    dispatcher.register("web_fetch", _web_fetch, _WEB_FETCH_SCHEMA)
```

---

### Phase C â€” Wire Into Runner (~15 min)

**File:** `nous/api/runner.py`

Update `FRAME_TOOLS`:

```python
FRAME_TOOLS: dict[str, list[str]] = {
    "conversation": [...],  # unchanged
    "question": ["recall_deep", "web_search", "web_fetch"],  # â† add web tools
    "decision": [...],      # unchanged
    "creative": [...],      # unchanged
    "task": ["*"],          # already gets web tools via wildcard
    "debug": [...],         # unchanged
}
```

Update `_get_frame_instructions()` for `question` frame:

```python
elif frame_id == "question":
    return (
        "## Tool Instructions\n\n"
        "You are in a QUESTION frame. Use `recall_deep` to search memory first. "
        "If the answer requires current or external information, use `web_search` "
        "to find it, then `web_fetch` to read specific pages."
    )
```

**File:** `nous/main.py` (or wherever tools are wired at startup)

```python
from nous.api.web_tools import register_web_tools
# After existing register_builtin_tools call:
register_web_tools(dispatcher, settings)
```

---

### Phase D â€” Tests (~45 min)

**New file:** `tests/test_web_tools.py`

Following `test_builtin_tools.py` pattern. Use `pytest-httpx` or `unittest.mock` to mock `httpx` calls.

| Test | What it verifies |
|---|---|
| `test_web_search_returns_results` | Happy path â€” results formatted correctly |
| `test_web_search_disabled` | Returns "disabled" message when `web_search_enabled=False` |
| `test_web_search_no_results` | Handles empty results gracefully |
| `test_web_search_rate_limited` | 429 â†’ friendly error message |
| `test_web_search_invalid_key` | 401 â†’ clear auth error |
| `test_web_fetch_success_html` | Fetches HTML, strips tags, returns text |
| `test_web_fetch_success_plaintext` | text/plain returned as-is |
| `test_web_fetch_invalid_scheme` | `file://`, `ftp://` â†’ rejected |
| `test_web_fetch_timeout` | Timeout â†’ friendly error message |
| `test_web_fetch_non_text_content` | PDF, image etc â†’ rejected with message |
| `test_web_fetch_truncation` | Content > 500KB â†’ truncated with marker |
| `test_register_web_tools_disabled` | No tools registered when disabled |
| `test_register_web_tools_enabled` | Both tools registered when enabled |

---

## ğŸ“ Files Changed Summary

| File | Change |
|---|---|
| `nous/api/web_tools.py` | **NEW** â€” ~150 lines, tool handlers + schemas + registration |
| `nous/config.py` | **MODIFY** â€” add 4 settings |
| `nous/api/runner.py` | **MODIFY** â€” add `web_search`/`web_fetch` to `question` frame + frame instructions |
| `nous/main.py` (or rest.py) | **MODIFY** â€” call `register_web_tools()` at startup |
| `.env.example` | **MODIFY** â€” add 3 env vars |
| `tests/test_web_tools.py` | **NEW** â€” ~200 lines |

**Total: ~350 lines, 2 new files, 4 small modifications.**

---

## â±ï¸ Effort Estimate

| Phase | Time |
|---|---|
| A â€” Config | 15 min |
| B â€” Tool handlers | 60 min |
| C â€” Wiring | 15 min |
| D â€” Tests | 45 min |
| **Total** | **~2.5 hours** |

---

## âœ… Definition of Done

- [ ] `NOUS_WEB_SEARCH_ENABLED=false` by default (feature-flagged off)
- [ ] `web_search` and `web_fetch` available in `question` and `task` frames
- [ ] All tests pass in CI with mocked HTTP (no real API calls)
- [ ] Graceful errors for: disabled, bad key, timeout, rate limit, bad URL, non-text content
- [ ] No new required dependencies (only stdlib + existing `httpx`)
- [ ] `.env.example` updated with new vars
