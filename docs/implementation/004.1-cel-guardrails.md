# 004.1: CEL Expression Guardrails

**Status:** Shipped (PR #10)
**Priority:** P1 — Enables flexible guardrails before Cognitive Layer ships
**Prerequisites:** 002-brain-module (merged)
**Origin:** [research/014 — Acteon Action Gateway](../research/014-acteon-action-gateway.md)

## Objective

Replace the rigid JSONB condition evaluator in `guardrails.py` with Google's Common Expression Language (CEL). This makes guardrails composable, readable, and able to access any field — eliminating the need for hardcoded condition keys.

### Before (JSONB)
```json
{"stakes": "high", "confidence_lt": 0.5}
```
- Only 4 recognized keys: `stakes`, `confidence_lt`, `reason_count_lt`, `quality_lt`
- Unknown keys silently ignored
- Can't reference tags, pattern, context, or custom fields

### After (CEL)
```cel
decision.stakes == 'high' && decision.confidence < 0.5
```
```cel
size(decision.tags) == 0 || !has(decision.pattern)
```
```cel
decision.category == 'architecture' && !decision.context.architecture_review
```
- Any field accessible via dot notation
- Boolean operators, comparisons, list functions
- Sandboxed — no side effects, no I/O

## Dependency

Add to `pyproject.toml`:
```toml
"cel-python>=0.4,<1.0",
```

## File Changes

### 1. `nous/brain/guardrails.py` (~120 lines, rewrite)

```python
"""Guardrail evaluation engine using CEL expressions.

Evaluates guardrail conditions as CEL expressions against a decision context.
CEL is sandboxed: no I/O, no side effects, deterministic evaluation.
"""

from __future__ import annotations

import logging
from datetime import UTC, datetime
from typing import Any

import celpy
from celpy import celtypes, Environment, Runner

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from nous.brain.schemas import GuardrailResult
from nous.storage.models import Event, Guardrail

logger = logging.getLogger(__name__)

# Shared CEL environment — thread-safe, reusable
_CEL_ENV = Environment()


def _to_cel_value(value: Any) -> Any:
    """Convert Python values to CEL-compatible types."""
    if isinstance(value, bool):
        return celtypes.BoolType(value)
    if isinstance(value, int):
        return celtypes.IntType(value)
    if isinstance(value, float):
        return celtypes.DoubleType(value)
    if isinstance(value, str):
        return celtypes.StringType(value)
    if isinstance(value, list):
        return celtypes.ListType([_to_cel_value(v) for v in value])
    if isinstance(value, dict):
        return celtypes.MapType({
            celtypes.StringType(k): _to_cel_value(v) for k, v in value.items()
        })
    if value is None:
        return celtypes.BoolType(False)  # CEL has no null; treat as false
    return celtypes.StringType(str(value))


def _build_activation(
    description: str,
    stakes: str,
    confidence: float,
    category: str | None = None,
    tags: list[str] | None = None,
    reasons: list[dict] | None = None,
    pattern: str | None = None,
    quality_score: float | None = None,
    context: dict | None = None,
) -> dict[str, Any]:
    """Build the CEL activation context as a 'decision' map."""
    decision = {
        "description": description,
        "stakes": stakes,
        "confidence": confidence,
        "category": category or "",
        "tags": tags or [],
        "reason_count": len(reasons or []),
        "reasons": reasons or [],
        "pattern": pattern or "",
        "quality_score": quality_score if quality_score is not None else 0.0,
        "has_pattern": pattern is not None and len(pattern) > 0,
        "has_tags": len(tags or []) > 0,
        "context": context or {},
    }
    return {"decision": _to_cel_value(decision)}


class GuardrailEngine:
    """Evaluate CEL guardrail expressions against decision context."""

    # Cache compiled CEL programs by expression string
    _program_cache: dict[str, Runner] = {}

    def _get_program(self, expression: str) -> Runner:
        """Compile and cache a CEL expression."""
        if expression not in self._program_cache:
            try:
                ast = _CEL_ENV.compile(expression)
                self._program_cache[expression] = _CEL_ENV.program(ast)
            except Exception:
                logger.error("Failed to compile CEL expression: %s", expression)
                raise
        return self._program_cache[expression]

    def _evaluate(self, expression: str, activation: dict) -> bool:
        """Evaluate a CEL expression. Returns True if condition matches."""
        try:
            program = self._get_program(expression)
            result = program.evaluate(activation)
            return bool(result)
        except Exception:
            logger.warning("CEL evaluation failed for: %s", expression, exc_info=True)
            return False  # Fail open — don't block on eval errors

    async def check(
        self,
        session: AsyncSession,
        agent_id: str,
        description: str,
        stakes: str,
        confidence: float,
        category: str | None = None,
        tags: list[str] | None = None,
        reasons: list[dict] | None = None,
        pattern: str | None = None,
        quality_score: float | None = None,
        context: dict | None = None,
    ) -> GuardrailResult:
        """Check all active guardrails for the agent.

        Args:
            context: Arbitrary key-value dict accessible as decision.context in CEL.
                     This is how callers pass custom fields (e.g., architecture_review=true).
        """
        result = await session.execute(
            select(Guardrail).where(
                Guardrail.agent_id == agent_id,
                Guardrail.active.is_(True),
            )
        )
        guardrails = result.scalars().all()

        activation = _build_activation(
            description=description,
            stakes=stakes,
            confidence=confidence,
            category=category,
            tags=tags,
            reasons=reasons,
            pattern=pattern,
            quality_score=quality_score,
            context=context,
        )

        blocked_by: list[str] = []
        warnings: list[str] = []

        for guardrail in guardrails:
            expression = self._get_expression(guardrail.condition)
            if expression and self._evaluate(expression, activation):
                if guardrail.severity in ("block", "absolute"):
                    blocked_by.append(guardrail.name)
                elif guardrail.severity == "warn":
                    warnings.append(guardrail.name)

                await session.execute(
                    update(Guardrail)
                    .where(Guardrail.id == guardrail.id)
                    .values(
                        activation_count=Guardrail.activation_count + 1,
                        last_activated=datetime.now(UTC),
                    )
                )

                event_type = "guardrail_blocked" if guardrail.severity in ("block", "absolute") else "guardrail_warned"
                session.add(Event(
                    agent_id=agent_id,
                    event_type=event_type,
                    data={
                        "guardrail_name": guardrail.name,
                        "severity": guardrail.severity,
                        "expression": expression,
                        "stakes": stakes,
                        "confidence": confidence,
                    },
                ))

        return GuardrailResult(allowed=len(blocked_by) == 0, blocked_by=blocked_by, warnings=warnings)

    def _get_expression(self, condition: dict | str) -> str | None:
        """Extract CEL expression from condition field.

        Supports two formats:
        1. String: direct CEL expression
           "decision.stakes == 'high' && decision.confidence < 0.5"

        2. Dict with 'cel' key: CEL expression in a dict
           {"cel": "decision.stakes == 'high'"}

        3. Legacy JSONB dict: auto-convert to CEL (backward compatible)
           {"stakes": "high", "confidence_lt": 0.5}
           → "decision.stakes == 'high' && decision.confidence < 0.5"
        """
        if isinstance(condition, str):
            return condition

        if isinstance(condition, dict):
            if "cel" in condition:
                return condition["cel"]
            # Legacy JSONB → CEL conversion
            return self._jsonb_to_cel(condition)

        return None

    def _jsonb_to_cel(self, condition: dict) -> str:
        """Convert legacy JSONB conditions to CEL expressions."""
        parts = []
        for key, value in condition.items():
            if key == "stakes":
                parts.append(f"decision.stakes == '{value}'")
            elif key == "confidence_lt":
                parts.append(f"decision.confidence < {value}")
            elif key == "reason_count_lt":
                parts.append(f"decision.reason_count < {value}")
            elif key == "quality_lt":
                parts.append(f"decision.quality_score < {value}")
            else:
                logger.warning("Unknown legacy condition key: %s (skipping)", key)
        return " && ".join(parts) if parts else "false"
```

### 2. `nous/brain/brain.py` — Update `check()` signature

Add `category` and `context` parameters to `Brain.check()` so callers can pass arbitrary context:

```python
async def check(
    self,
    description: str,
    stakes: str,
    confidence: float,
    category: str | None = None,
    tags: list[str] | None = None,
    reasons: list[dict] | None = None,
    pattern: str | None = None,
    quality_score: float | None = None,
    context: dict | None = None,  # NEW — arbitrary context for CEL
    session: AsyncSession | None = None,
) -> GuardrailResult:
```

### 3. `sql/seed.sql` — Update default guardrails to CEL

```sql
-- Replace existing guardrails with CEL expressions
DELETE FROM brain.guardrails WHERE agent_id = 'nous-default';
INSERT INTO brain.guardrails (agent_id, name, description, condition, severity) VALUES
    ('nous-default', 'no-high-stakes-low-confidence',
     'Block high-stakes decisions with low confidence',
     '{"cel": "decision.stakes == ''high'' && decision.confidence < 0.5"}',
     'block'),
    ('nous-default', 'no-critical-without-review',
     'Block critical-stakes without explicit review',
     '{"cel": "decision.stakes == ''critical''"}',
     'block'),
    ('nous-default', 'require-reasons',
     'Block decisions without at least one reason',
     '{"cel": "decision.reason_count < 1"}',
     'block'),
    ('nous-default', 'low-quality-recording',
     'Block low-quality decisions (missing tags/pattern)',
     '{"cel": "decision.quality_score < 0.5"}',
     'block');
```

### 4. `pyproject.toml` — Add dependency

```toml
dependencies = [
    ...
    "cel-python>=0.4,<1.0",
]
```

## Test Specification

### `tests/test_guardrails.py` — Update existing + add new (~80 lines added)

```python
# Existing tests should still pass (legacy JSONB auto-converted to CEL)

# NEW tests:
# test_cel_expression_string — condition as raw CEL string
# test_cel_expression_dict — condition as {"cel": "..."}
# test_cel_context_access — decision.context.custom_field accessible
# test_cel_tag_check — "size(decision.tags) > 0" works
# test_cel_pattern_check — "decision.has_pattern" works
# test_cel_complex_expression — "decision.stakes == 'high' && decision.category == 'architecture' && !decision.context.architecture_review"
# test_cel_invalid_expression — bad syntax → fail open (no block)
# test_cel_legacy_jsonb_compat — old JSONB conditions still work
# test_cel_program_cache — same expression compiled once
```

## Migration

### Backward Compatible
- Legacy JSONB conditions auto-convert to CEL via `_jsonb_to_cel()`
- Existing guardrails in the DB continue to work without changes
- New guardrails can use either format

### Recommended Migration Path
1. Ship with backward compatibility
2. Gradually update guardrails to native CEL expressions
3. Eventually deprecate JSONB format

## Design Decisions

### D1: Fail open on evaluation errors
If a CEL expression fails to compile or evaluate, the guardrail does NOT trigger. This prevents broken expressions from blocking all decisions. Errors are logged at WARNING level.

### D2: Program cache
CEL compilation is expensive (~1ms). Programs are cached by expression string. The cache lives on the GuardrailEngine instance. Thread-safe because CEL programs are immutable.

### D3: `decision` namespace
All fields live under `decision.*` in CEL. This is cleaner than flat variables and leaves room for future namespaces (e.g., `agent.*`, `session.*`).

### D4: Null handling
CEL has no null type. None values are converted to type-appropriate defaults: empty string, 0, false, empty list. `has_pattern` and `has_tags` boolean helpers provided for explicit null checks.

### D5: Context dict for custom fields
`decision.context` is an arbitrary map. This solves the CE MCP guardrail gap — callers pass `context={"architecture_review": true}` and CEL expressions access it as `decision.context.architecture_review`.
